<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>swift-evolution 0258-property-wrappers | 浮生闲记</title>
<meta name="description" content="要么有趣,要么老去." />
<link rel="shortcut icon" href="http://v1ki.top//favicon.ico?v=1579726655155">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://v1ki.top//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-153511680-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-153511680-1');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://v1ki.top/">
  <img class="avatar" src="http://v1ki.top//images/avatar.png?v=1579726655155" alt="">
  </a>
  <h1 class="site-title">
    浮生闲记
  </h1>
  <p class="site-description">
    要么有趣,要么老去.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              swift-evolution 0258-property-wrappers
            </h2>
            <div class="post-info">
              <span>
                2020-01-21
              </span>
              <span>
                35 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>原文链接： <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md">0258-property-wrappers</a></p>
<h1 id="property-wrappers-属性封装器">Property Wrappers ( 属性封装器 )</h1>
<h2 id="前言">前言</h2>
<p>  有一些属性实现模式总是反复出现,而不是将一组固定的模式硬编码至编译器 ( 就像 <code>lazy</code>  和 <code>@NSCopying</code> 这样 ) . 我们应该提供一个常用的 “ 属性封装器 ” 机制来让这些模式可以被定义为库.<br>
   这个可以为作为替代  <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md">2015-2016 property behaviors proposal</a>   的一些问题的解决方案. 一些示例是相同的, 但是这个提案一个完整的不同的方式 , 使得设计变得更加简单 , 更容易被用户理解 , 并且对编译器的实施的侵入性更少 . 在本提案末尾 , 有一节讨论了与该设计的实质区别.</p>
<h2 id="动机">动机</h2>
<p>我们已尝试对于 目标语言支持的属性提供几种重要的模式 .比如说 <code>lazy</code>和 <code>@NSCopying</code> , 但是这种支持的范围和实用性一直很狭窄 . 例如 , Swift 提供 <code>lazy</code> 属性作为语言的原生特性.  因为懒加载是很常见的, 并且通常是避免属性作为 <code>Optional</code>  是必需的. 如果没有了这个语言特性,  将会花很多代码来达成相同的效果.</p>
<pre><code>struct Foo {
  // lazy var foo = 1738
  private var _foo: Int?
  var foo: Int {
    get {
      if let value = _foo { return value }
      let initialValue = 1738
      _foo = initialValue
      return initialValue
    }
    set {
      _foo = newValue
    }
  }
}
</code></pre>
<p>将<code>lazy</code> 构建进Swfit 有几个缺点. 他使 Swift和其编译器变得更加复杂 , 且不那么正交. 而且也不灵活.  有很多有意义的懒加载变体,但是我们不想对所有的进行硬编码语言支持.</p>
<p>除了懒加载之后 , 还有一些重要的属性模式 , 拥有 &quot;延时 &quot;, 一旦赋值然后就不可变的属性 来支持 多个阶段的初始化通常是有意义:</p>
<pre><code>class Foo {
  let immediatelyInitialized = &quot;foo&quot;
  var _initializedLater: String?

  // We want initializedLater to present like a non-optional 'let' to user code;
  // it can only be assigned once, and can't be accessed before being assigned.
  var initializedLater: String {
    get { return _initializedLater! }
    set {
      assert(_initializedLater == nil)
      _initializedLater = newValue
    }
  }
}
</code></pre>
<p>隐式展开的可选项允许在紧急情况下使用此选项 , 但是对比 一个非可选的 <code>let</code> 来说放弃了很多的安全性.  使用 IUO 来多阶段初始化 放弃了包括 不变性以及 nil-safety .</p>
<p><code>@NSCopying</code> 属性 引入了 <code>NSCopying.copy()</code>  来在分配时创建一个复制. 这个实现模式可能看起来很熟悉:</p>
<pre><code>class Foo {
  // @NSCopying var text: NSAttributedString
  var _text: NSAttributedString
  var text: NSAttributedString {
    get { return _text }
    set { _text = newValue.copy() as! NSAttributedString }
  }
}
</code></pre>
<h2 id="解决方案">解决方案</h2>
<p>我们建议引入属性封装器 , 该属性封装器 允许 属性在声明时决定让哪个封装 来实现他. 通过属性来描述 封装器 :</p>
<pre><code>@Lazy var foo = 1738
</code></pre>
<p>这以 <code>Lazy</code> 的属性封装器器 类型描述的方式来实现了<code>foo</code> 属性:</p>
<pre><code>@propertyWrapper
enum Lazy&lt;Value&gt; {
  case uninitialized(() -&gt; Value)
  case initialized(Value)

  init(wrappedValue: @autoclosure @escaping () -&gt; Value) {
    self = .uninitialized(wrappedValue)
  }

  var wrappedValue: Value {
    mutating get {
      switch self {
      case .uninitialized(let initializer):
        let value = initializer()
        self = .initialized(value)
        return value
      case .initialized(let value):
        return value
      }
    }
    set {
      self = .initialized(newValue)
    }
  }
}
</code></pre>
<p>属性封装器 类型 提供了 将其用作 封装器的属性的存储 .   封装器类型的<code>wrappedValue</code> 属性 提供了封装器的实际实现. 可选的 <code>init(wrappedValue:)</code> 可以根据属性类型的值 来初始化存储  .   属性声明为:</p>
<pre><code>@Lazy var foo = 1738
</code></pre>
<p>转换为:</p>
<pre><code>private var _foo: Lazy&lt;Int&gt; = Lazy&lt;Int&gt;(wrappedValue: 1738)
var foo: Int {
  get { return _foo.wrappedValue }
  set { _foo.wrappedValue = newValue }
}
</code></pre>
<p>特意将前缀<code>_</code>用作 合成存储属性的名称: 它为合成存储属性 提供了一个可预测的名称, 该名称符合 <code>private</code> 存储属性的命名规范. 比如 ,我们可以 提供 一个 <code>reset(_:)</code> 操作符给 <code>Lazy</code> 来将它设置成一个新的值 :</p>
<pre><code>extension Lazy {
  /// Reset the state back to &quot;uninitialized&quot; with a new,
  /// possibly-different initial value to be computed on the next access.
  mutating func reset(_ newValue:  @autoclosure @escaping () -&gt; Value) {
    self = .uninitialized(newValue)
  }
}

_foo.reset(42)
</code></pre>
<p>这个备用的存储属性也可以被显式初始化,像这样:</p>
<pre><code>extension Lazy {
  init(body: @escaping () -&gt; Value) {
    self = .uninitialized(body)
  }
}

func createAString() -&gt; String { ... }

@Lazy var bar: String  // not initialized yet
_bar = Lazy(body: createAString)
</code></pre>
<p>属性封装器的实例 可以通过提供一个在名称后括号中的初始化参数来直接初始化.  上面的代码可以替换成一个简单的声明 ,如下所示 :</p>
<pre><code>@Lazy(body: createAString) var bar: String
</code></pre>
<p>属性封装器可以被应用到全局, 局部, 或类型范围的属性. 这些属性可以拥有观察访问者 ( <code>willSet / didSet</code> ) ,但是不能具有显示编写 的<code>getters</code> 或者 <code>setter</code>  .</p>
<p><code>Lazy</code> 属性封装器在它的构造器之外几乎没有 或者 没有有趣的API . 因此将其导出给客户并不重要. 但是 , 属性封装器也可以描述本身就有 有趣 API的 丰富关系 . 例如 , 我们可能会有一个属性封装器的概念, 该属性封装器引用了一个通过名称来建立的数据库字段 .</p>
<pre><code>@propertyWrapper
public struct Field&lt;Value: DatabaseValue&gt; {
  public let name: String
  private var record: DatabaseRecord?
  private var cachedValue: Value?
  
  public init(name: String) {
    self.name = name
  }

  public func configure(record: DatabaseRecord) {
    self.record = record
  }
  
  public var wrappedValue: Value {
    mutating get {
      if cachedValue == nil { fetch() }
      return cachedValue!
    }
    
    set {
      cachedValue = newValue
    }
  }
  
  public func flush() {
    if let value = cachedValue {
      record!.flush(fieldName: name, value)
    }
  }
  
  public mutating func fetch() {
    cachedValue = record!.fetch(fieldName: name, type: Value.self)
  }
}
</code></pre>
<p>我们可以基于 <code>Field</code> 属性封装器来建立我们自己的数据模型.</p>
<pre><code>public struct Person: DatabaseModel {
  @Field(name: &quot;first_name&quot;) public var firstName: String
  @Field(name: &quot;last_name&quot;) public var lastName: String
  @Field(name: &quot;date_of_birth&quot;) public var birthdate: Date
}
</code></pre>
<p><code>Field</code> 本身具有对<code>Person</code> 用户重要的API : 它让我们可以刷新现有值. 获取新的值, 并且检索数据库中相应字段的名称. 但是 , 我们模型中的每个属性(<code>_firstName</code>, <code>_lastName</code>,<code>_birthdate</code>) 的 带下划线变量都是 <code>private</code> , 所以我们的用户无法直接操作它们.</p>
<p>为了发布API, <code>Field</code> 属性封装器可以提供 一个映射来让我们操作 字段与数据库之间的关系. 映射属性 带有 <code>$</code>前缀, 所以 <code>firstName</code> 属性的映射属性被称为 <code>$firstName</code> ,并且当 <code>firstName</code>可见时也可见. 属性封装器类型 通过定义 <code>projectedValue</code> 属性来选择提供映射 :</p>
<pre><code>@propertyWrapper
public struct Field&lt;Value: DatabaseValue&gt; {
  // ... API as before ...
  
  public var projectedValue: Self {
    get { self }
    set { self = newValue }
  }
}
</code></pre>
<p>当<code>projectedValue</code> 存在时, 映射属性被创建为<code>projectedValue</code> 的封装器 . 例如 , 如下属性为:</p>
<pre><code>@Field(name: &quot;first_name&quot;) public var firstName: String
</code></pre>
<p>可以扩展为:</p>
<pre><code>private var _firstName: Field&lt;String&gt; = Field(name: &quot;first_name&quot;)

public var firstName: String {
  get { _firstName.wrappedValue }
  set { _firstName.wrappedValue = newValue }
}

public var $firstName: Field&lt;String&gt; {
  get { _firstName.projectedValue }
  set { _firstName.projectedValue = newValue }
}
</code></pre>
<p>这个允许用户同时操作属性和其映射 , 例如:</p>
<pre><code>somePerson.firstName = &quot;Taylor&quot;
$somePerson.flush()
</code></pre>
<h2 id="示例">示例</h2>
<p>在描述设计细节之前,下面有几个封装器的示例</p>
<h3 id="延时初始化">延时初始化</h3>
<p>属性封装器可以 &quot;延迟&quot; 初始化进行建模 , 在该初始化中, 属性的定义初始化(DI)规则是强制动态执行的 , 而不是在编译时执行的. 这个可以避免在多阶段初始化中使用隐式展开的可选对象. 我们可以实现一个可变的变量,允许像<code>var</code> 一样重复赋值.</p>
<pre><code>@propertyWrapper
struct DelayedMutable&lt;Value&gt; {
  private var _value: Value? = nil

  var wrappedValue: Value {
    get {
      guard let value = _value else {
        fatalError(&quot;property accessed before being initialized&quot;)
      }
      return value
    }
    set {
      _value = newValue
    }
  }

  /// &quot;Reset&quot; the wrapper so it can be initialized again.
  mutating func reset() {
    _value = nil
  }
}
</code></pre>
<p>和一个不变的变量, 像<code>let</code>一样只允许一次初始化  :</p>
<pre><code>@propertyWrapper
struct DelayedImmutable&lt;Value&gt; {
  private var _value: Value? = nil

  var wrappedValue: Value {
    get {
      guard let value = _value else {
        fatalError(&quot;property accessed before being initialized&quot;)
      }
      return value
    }

    // Perform an initialization, trapping if the
    // value is already initialized.
    set {
      if _value != nil {
        fatalError(&quot;property initialized twice&quot;)
      }
      _value = newValue
    }
  }
}
</code></pre>
<p>可以多阶段初始化,像这样:</p>
<pre><code>class Foo {
  @DelayedImmutable var x: Int

  init() {
    // We don't know &quot;x&quot; yet, and we don't have to set it
  }

  func initializeX(x: Int) {
    self.x = x // Will crash if 'self.x' is already initialized
  }

  func getX() -&gt; Int {
    return x // Will crash if 'self.x' wasn't initialized
  }
}
</code></pre>
<h3 id="nscopying">NSCopying</h3>
<p>许多Cocoa class 都实现 需要显式复制<code>value-like</code> 对象 . Swift 当前为属性提供 <code>@NSCopying</code> 属性 , 以赋予它们类似 Objective-C 的 <code>@property(copy)</code> 的行为,并且在设置属性时在新对象时调用 <code>copy</code> 方法. 我们可以将其变成封装器:</p>
<pre><code>@propertyWrapper
struct Copying&lt;Value: NSCopying&gt; {
  private var _value: Value
  
  init(wrappedValue value: Value) {
    // Copy the value on initialization.
    self._value = value.copy() as! Value
  }

  var wrappedValue: Value {
    get { return _value }
    set {
      // Copy the value on reassignment.
      _value = newValue.copy() as! Value
    }
  }
}
</code></pre>
<p>此实现将解决<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.md">SE-0153</a>中详述的问题.将<code>copy()</code>放在<code>init(wrappedValue:)</code>之外可实现 SE-0153 前的语义.</p>
<h3 id="原子性">原子性</h3>
<p>对 原子操作符( load , store , increment / decrement , compare-and-exchange ) 的支持是一种常见的Swift 功能. 尽管此功能的实现细节涉及到编译器和标准库魔术, 这些接口本身可以很好的表示属性封装器类型 :</p>
<pre><code>@propertyWrapper
struct Atomic&lt;Value&gt; {
  private var _value: Value
  
  init(wrappedValue: Value) {
    self._value = wrappedValue
  }

  var wrappedValue: Value {
    get { return load() }
    set { store(newValue: newValue) }
  }
  
  func load(order: MemoryOrder = .relaxed) { ... }
  mutating func store(newValue: Value, order: MemoryOrder = .relaxed) { ... }
  mutating func increment() { ... }
  mutating func decrement() { ... }
}

extension Atomic where Value: Equatable {
  mutating func compareAndExchange(oldValue: Value, newValue: Value, order: MemoryOrder = .relaxed)  -&gt; Bool { 
    ...
  }
}  

enum MemoryOrder {
  case relaxed, consume, acquire, release, acquireRelease, sequentiallyConsistent
};
</code></pre>
<p>这里有一些简单关于原子性的使用. 对于原子性类型来说, 通常需要编织低等级的原子操作符(<code>increment</code>, <code>load</code>, <code>compareAndExchange</code>)  ,在这些操作中,我们需要通过简单查询获得特定语义(例如内存顺序), 因此经常使用该属性和合成属性:</p>
<pre><code>@Atomic var counter: Int

if thingHappened {
  _counter.increment()
}
print(counter)

@Atomic var initializedOnce: Int?
if initializedOnce == nil {
  let newValue: Int = /*computeNewValue*/
  if !_initializedOnce.compareAndExchange(oldValue: nil, newValue: newValue) {
    // okay, someone else initialized it. clean up if needed
  }
}
print(initializedOnce)
</code></pre>
<h3 id="指定线程存储">指定线程存储</h3>
<p>指定线程存储 (基于<code>pthreads</code>) 可以作为一个 属性封装器实现 :</p>
<pre><code>@propertyWrapper
final class ThreadSpecific&lt;T&gt; {
  private var key = pthread_key_t()
  private let initialValue: T

  init(key: pthread_key_t, wrappedValue: T) {
    self.key = key
    self.initialValue = wrappedValue
  }

  init(wrappedValue: T) {
    self.initialValue = wrappedValue
    pthread_key_create(&amp;key) {
      // 'Any' erasure due to inability to capture 'self' or &lt;T&gt;
      $0.assumingMemoryBound(to: Any.self).deinitialize(count: 1)
      $0.deallocate()
    }
  }

  deinit {
    fatalError(&quot;\(ThreadSpecific&lt;T&gt;.self).deinit is unsafe and would leak&quot;)
  }

  private var box: UnsafeMutablePointer&lt;Any&gt; {
    if let pointer = pthread_getspecific(key) {
      return pointer.assumingMemoryBound(to: Any.self)
    } else {
      let pointer = UnsafeMutablePointer&lt;Any&gt;.allocate(capacity: 1)
      pthread_setspecific(key, UnsafeRawPointer(pointer))
      pointer.initialize(to: initialValue as Any)
      return pointer
    }
  }

  var wrappedValue: T {
    get { return box.pointee as! T }
    set (v) {
      box.withMemoryRebound(to: T.self, capacity: 1) { $0.pointee = v }
    }
  }
}
</code></pre>
<h3 id="user-defaults">User defaults</h3>
<p>属性封装器可用于为 &quot;string-keyed&quot; 的数据提供类型化的属性, 就像  UserDefaults , 将提取数据的机制封装在封装器类型中. 例如:</p>
<pre><code>@propertyWrapper
struct UserDefault&lt;T&gt; {
  let key: String
  let defaultValue: T
  
  var wrappedValue: T {
    get {
      return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
    }
    set {
      UserDefaults.standard.set(newValue, forKey: key)
    }
  }
}

enum GlobalSettings {
  @UserDefault(key: &quot;FOO_FEATURE_ENABLED&quot;, defaultValue: false)
  static var isFooFeatureEnabled: Bool
  
  @UserDefault(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)
  static var isBarFeatureEnabled: Bool
}
</code></pre>
<h3 id="copy-on-write">Copy-on-write</h3>
<p>对于一些场景来说 , 属性封装器可以提供 <code>copy-on-write</code> 封装器 :</p>
<pre><code>protocol Copyable: AnyObject {
  func copy() -&gt; Self
}

@propertyWrapper
struct CopyOnWrite&lt;Value: Copyable&gt; {
  init(wrappedValue: Value) {
    self.wrappedValue = wrappedValue
  }
  
  private(set) var wrappedValue: Value
  
  var projectedValue: Value {
    mutating get {
      if !isKnownUniquelyReferenced(&amp;wrappedValue) {
        wrappedValue = value.copy()
      }
      return wrappedValue
    }
    set {
      wrappedValue = newValue
    }
  }
}
</code></pre>
<p><code>projectedValue</code> 为合成存储属性提供映射,允许 <code>copy-on-write</code> 封装器直接可以直接被使用:</p>
<pre><code>@CopyOnWrite var storage: MyStorageBuffer

// Non-modifying access:
let index = storage.index(of: …)

// For modification, access $storage, which goes through `projectedValue`:
$storage.append(…)
</code></pre>
<h3 id="ref-box">Ref / Box</h3>
<p>我们可以定义一个属性封装器类型 <code>Ref</code> ,它是对 可以 获取/设置的某些值的抽象引用, 它实际上是一个程序化的计算类型 .</p>
<pre><code>@propertyWrapper
struct Ref&lt;Value&gt; {
  let read: () -&gt; Value
  let write: (Value) -&gt; Void

  var wrappedValue: Value {
    get { return read() }
    nonmutating set { write(newValue) }
  }

  subscript&lt;U&gt;(dynamicMember keyPath: WritableKeyPath&lt;Value, U&gt;) -&gt; Ref&lt;U&gt; {
    return Ref&lt;U&gt;(
        read: { self.wrappedValue[keyPath: keyPath] },
        write: { self.wrappedValue[keyPath: keyPath] = $0 })
  }
}
</code></pre>
<p>下标使用 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md">SE-0252 &quot;Key Path Member Lookup&quot;</a> , 以便 <code>Ref</code> 实例提供访问其属性. 下面示例以SE-0252为基础:</p>
<pre><code>@Ref(read: ..., write: ...)
var rect: Rectangle

print(rect)          // accesses the Rectangle
print(rect.topLeft)  // accesses the topLeft component of the rectangle

let rect2 = $rect    // get the Ref&lt;Rectangle&gt;
let topLeft2 = $rect.topLeft // get a Ref&lt;Point&gt; referring to the Rectangle's topLeft
</code></pre>
<p><code>Ref</code> 类型封装 读/写 ,并使其成为 属性封装器 ,  这样我们就可以看到基础值了.  通常, 人们不想显示写出 <code>getter</code> / <code>setter</code> ,并且拥有 <code>Box</code> 类型来包装一个值并可以 将 <code>Ref</code> 实例发布给 该 box 是很常见的. 我们也可以使用另外一种属性封装器实现 :</p>
<pre><code>@propertyWrapper
class Box&lt;Value&gt; {
  var wrappedValue: Value

  init(wrappedValue: Value) {
    self.wrappedValue = wrappedValue
  }

  var projectedValue: Ref&lt;Value&gt; {
    return Ref&lt;Value&gt;(read: { self.wrappedValue }, write: { self.wrappedValue = $0 })
  }
}
</code></pre>
<p>现在我们可以直接定义一个新的 <code>Box</code> :</p>
<pre><code>@Box var rectangle: Rectangle = ...

print(rectangle)  // access the rectangle
print(rectangle.topLeft) // access the top left coordinate of the rectangle
let rect2 = $rectangle   // through projectedValue, produces a Ref&lt;Rectangle&gt;
let topLeft2 = $rectangle.topLeft   // through projectedValue, produces a Ref&lt;Point&gt;
</code></pre>
<p>使用<code>projectedValue</code> 会隐藏用户的box( <code>_rectangle</code> 保持私有 ) ,提供直接访问到box的值(通常状态下)  以及通过<code>Ref</code>(称为<code>$rectangle</code>)访问box的内容.</p>
<h3 id="限制范围内的值">&quot;限制&quot;范围内的值</h3>
<p>属性封装器可以限制存储值在特定范围内, 例如 , <code>Clamping</code> 属性封装器提供 最小/最大范围 来将值限制在其中 :</p>
<pre><code>@propertyWrapper
struct Clamping&lt;V: Comparable&gt; {
  var value: V
  let min: V
  let max: V

  init(wrappedValue: V, min: V, max: V) {
    value = wrappedValue
    self.min = min
    self.max = max
    assert(value &gt;= min &amp;&amp; value &lt;= max)
  }

  var wrappedValue: V {
    get { return value }
    set {
      if newValue &lt; min {
        value = min
      } else if newValue &gt; max {
        value = max
      } else {
        value = newValue
      }
    }
  }
}
</code></pre>
<p>这个示例中最有趣的是 <code>@Clamping</code> 属性可以通过传递初始化参数或者给初始值来进行初始化 . 在这样的示例中, <code>wrappedValue:</code> 参数是放在第一位的. 例如, 我们可以定义一个 <code>Color</code> 类型,该类型的值被限制在[0,255] 的范围中了 :</p>
<pre><code>struct Color {
  @Clamping(min: 0, max: 255) var red: Int = 127
  @Clamping(min: 0, max: 255) var green: Int = 127
  @Clamping(min: 0, max: 255) var blue: Int = 127
  @Clamping(min: 0, max: 255) var alpha: Int = 255
}
</code></pre>
<p>合成成员式的构造器展示了初始化本身是如何形成的:</p>
<pre><code>init(red: Int = 127, green: Int = 127, blue: Int = 127, alpha: Int = 255) {
  _red = Clamping(wrappedValue: red, min: 0, max: 255)
  _green = Clamping(wrappedValue: green, min: 0, max: 255)
  _blue = Clamping(wrappedValue: blue, min: 0, max: 255)
  _alpha = Clamping(wrappedValue: alpha, min: 0, max: 255)
}
</code></pre>
<h3 id="property-wrapper-types-in-the-wild">Property wrapper types in the wild</h3>
<p>有许多现有的类型已经提供了属性封装器类型的基础结构 . 其中一个比较有趣的案例是 <code>Unsafe(Mutable)Pointer</code> , 我们可以对其进行扩展以允许轻松访问指向的值.</p>
<pre><code>@propertyWrapper
struct UnsafeMutablePointer&lt;Pointee&gt; {
  var pointee: Pointee { ... }
  
  var wrappedValue: Pointee {
    get { return pointee }
    set { pointee = newValue }
  }
}
</code></pre>
<p>从用户角度来看, 这使我们可以一次设置不安全可变的指针的地址,然后主要引用指向的值 :</p>
<pre><code>@UnsafeMutablePointer(mutating: addressOfAnInt)
var someInt: Int

someInt = 17 // equivalent to _someInt.pointee = 17
print(someInt)

_someInt.deallocate()
</code></pre>
<p>RxCocoa's <code>BehaviorRelay</code> 为每个订阅的观察者重放了提供的最新值. 它是使用初始值来创建 的, 有<code>wrappedValue</code> 属性来访问当前的值,并且<code>projectedValue</code>  来公开提供API的映射 来订阅新的观察者 :</p>
<pre><code>@BehaviorRelay
var myValue: Int = 17

let observer = $myValue.subscribe(...)   // subscribe an observer
$myValue.accept(42)  // set a new value via the synthesized storage property

print(myValue)   // print the most recent value
</code></pre>
<p>这和 Combine's <code>Published</code> 属性封装器很神似 , 允许用户来订阅 <code>@Published</code>属性(通过 <code>$</code> 来映射) 以在值发生变化的时接收更新.<br>
SwiftUI 广泛使用属性封装器来声明 局部状态( <code>@State</code> ) ,并表达了对可能影响UI的其他状态的数据依耐性(<code>@EnvironmentObject</code>, <code>@Environment</code>, <code>@ObjectBinding</code>). 它广泛使用了 <code>Binding</code> 属性封装器的映射,来允许影响UI的状态的可控变化.</p>
<h3 id="属性封装器的组合">属性封装器的组合</h3>
<p>当为给定的属性提供多个属性封装器时, 封装器将组合在一起来同时获得所有的效果. 例如, 考虑下 <code>DelayedMutable</code> 和<code>Copying</code> 的组合:</p>
<pre><code>@DelayedMutable @Copying var path: UIBezierPath
</code></pre>
<p>这样我们就有一个可以懒加载的属性,并且当我们设置它的值时,将通过 <code>NSCopying</code>的<code>copy</code> 方法将其复制.<br>
通过将后面的封装器类型嵌套在前面的封装器类型来实现组合的 , 其中最里面的嵌套类型是原始属性的类型. 比如说上面的示例, 备用存储的类型将会是 <code>DelayedMutable&lt;Copying&lt;UIBezierPath&gt;&gt;</code>  , 并且对于<code>path</code> 合成的 gettter / setter 将遍历所有层次的<code>.wrappedValue</code>  :</p>
<pre><code>private var _path: DelayedMutable&lt;Copying&lt;UIBezierPath&gt;&gt; = .init()
var path: UIBezierPath {
  get { return _path.wrappedValue.wrappedValue }
  set { _path.wrappedValue.wrappedValue = newValue }
}  
</code></pre>
<p>请注意,这个设计表明 属性封装器组合是 不可交换顺序的. 因为属性的顺序会影响嵌套的执行方式:</p>
<pre><code>@DelayedMutable @Copying var path1: UIBezierPath   // _path1 has type DelayedMutable&lt;Copying&lt;UIBezierPath&gt;&gt;
@Copying @DelayedMutable var path2: UIBezierPath   // error: _path2 has ill-formed type Copying&lt;DelayedMutable&lt;UIBezierPath&gt;&gt;
</code></pre>
<p>在这个示例中, 类型检查器会阻止第二种方式 , 因为 <code>DelayedMutable</code> 没有实现 <code>NSCopying</code> 协议 , 并不是所有的情况都是这样:  某些语义不太好的组合并不一定会被 类型检查器捕获,  在 &quot;Alternatives considered&quot; 中介绍了 这种组合方案的替代方法.</p>
<h2 id="设计细节">设计细节</h2>
<h3 id="属性封装器类型">属性封装器类型</h3>
<p>属性封装器类型是可以用 封装属性的类型.  对于属性封装器来说,有两个基础要求:</p>
<ol>
<li>属性封装器类型一定要使用<code>@propertyWrapper</code> 属性来定义,  该属性表明该类型是要用作属性封装器类型,且提供一个点, 编译器可以在该点上验证任何其他的一致性规则.</li>
<li>属性封装器类型 一定要有 <code>wrappedValue</code> 属性, 该属性的访问等级和封装器类型的等级一致. 这是编译器用来访问封装器实例上的值的属性.</li>
</ol>
<h3 id="合成存储属性的初始化">合成存储属性的初始化</h3>
<p>向属性引入属性封装器可以使 该属性被计算(使用 getter / setter ) ,并引入一个类型为封装器类型的存储属性. 该存储属性可以使用如下三种方式来进行初始化:</p>
<ol>
<li>通过原有属性类型的值( 比如 在<code>@Lazy var foo : Int</code> 中的 <code>Int</code> ,使用 属性封装器类型的 <code>init(wrappedValue:)</code> 构造器. 该构造器必须具有与 <code>wrappedValue</code> 属性类型一致的参数( 或者是 <code>@autoclosure</code> ) , 且拥有和属性封装器类型相同的访问等级. 当 <code>init(wrappedValue:)</code> 存在时,  则通常会用作属性声明时的初始值.</li>
</ol>
<pre><code>@Lazy var foo = 17

// ... implemented as
private var _foo: Lazy = Lazy(wrappedValue: 17)
var foo: Int { /* access via _foo.wrappedValue as described above */ }
</code></pre>
<p>当有多个属性封装器进行组合时, 它们必须都要提供<code>init(wrappedValue:)</code>  ,且初始化的结果将封装每个调用层次 :</p>
<pre><code>@Lazy @Copying var path = UIBezierPath()

// ... implemented as
private var _path: Lazy&lt;Copying&lt;UIBezierPath&gt;&gt; = .init(wrappedValue: .init(wrappedValue: UIBezierPath()))
var path: UIBezierPath { /* access via _path.wrappedValue.wrappedValue as described above */ }
</code></pre>
<ol start="2">
<li>通过属性封装器类型的值,通过将初始化参数放在属性封装器类型后面:</li>
</ol>
<pre><code>var addressOfInt: UnsafePointer&lt;Int&gt; = ...

@UnsafeMutablePointer(mutating: addressOfInt) 
var someInt: Int

// ... implemented as
private var _someInt: UnsafeMutablePointer&lt;Int&gt; = UnsafeMutablePointer(mutating: addressOfInt)
var someInt: Int { /* access via _someInt.wrappedValue */ }
</code></pre>
<p>当有多个属性封装器进行组合时, 只有第一个(最外层的)  封装器可以有初始化参数.<br>
3. 隐式的 , 当没提供构造器 ,且属性封装类型提供了无参的构造器 (<code>init()</code>) . 这种情况下, 将会调用封装器类型的 <code>init()</code> 来初始化存储属性:</p>
<pre><code>@DelayedMutable var x: Int

// ... implemented as
private var _x: DelayedMutable&lt;Int&gt; = DelayedMutable&lt;Int&gt;()
var x: Int { /* access via _x.wrappedValue */ }
</code></pre>
<p>当有多个属性封装器进行组合时, 只有第一个(最外层的)  封装器才需要有 <code>init()</code>.</p>
<h3 id="使用属性封装器进行类型推导">使用属性封装器进行类型推导</h3>
<p>如果第一个属性封装器类型是泛型的,则必须在属性中显示的给出其泛型参数, 或者 Swift 必须能从变量声明中推导出来. 推导过程如下:</p>
<ul>
<li>当变量有初始值 <code>E</code> 时, 则第一个封装器类型 限制为等于调用  <code>A(wrappedValue: E, argsA...)</code>得到的类型, 其中,<code>A</code>是该属性的书面类型, <code>argsA</code> 是提供给该属性的参数 . 例如 :</li>
</ul>
<pre><code>@Lazy var foo = 17
// type inference as in...
private var _foo: Lazy = Lazy(wrappedValue: 17)
// infers the type of '_foo' to be 'Lazy&lt;Int&gt;'
</code></pre>
<p>如果有多个封装器属性的话, 则此调用的参数将是对 下一个属性的书面类型 <code>B(wrappedValue: E, argsB...)</code> 的嵌套调用, 以此类推 , 例如 :</p>
<pre><code>@A @B(name: &quot;Hello&quot;) var bar = 42
// type inference as in ...
private var _bar = A(wrappedValue: B(wrappedValue: 42, name: &quot;Hello&quot;))
// infers the type of '_bar' to be 'A&lt;B&lt;Int&gt;'
</code></pre>
<ul>
<li>当变量没有初始值 <code>E</code> 时, 如果第一个封装器属性有直接初始化参数 <code>E...</code> , 那么最外层的封装器类型限制为等于 调用 <code>A(E...)</code> 得到的类型, 其中,<code>A</code>是该属性的书面类型, 在第一个封装器属性后面的可能没有直接构造器 . 例如 :</li>
</ul>
<pre><code>@UnsafeMutablePointer(mutating: addressOfInt)
var someInt
// type inference as in...
private var _someInt: UnsafeMutablePointer = UnsafeMutablePointer.init(mutating: addressOfInt)
// infers the type of `_someInt` to be `UnsafeMutablePointer&lt;Int&gt;`
</code></pre>
<ul>
<li>当变量没有初始值 <code>E</code> 时, 且没有构造器时 , 且原始属性有类型注解, 最后一个封装器类型的<code>wrappedValue</code> 属性类型等同于原始属性的类型注解. 例如:</li>
</ul>
<pre><code>@propertyWrapper
struct Function&lt;T, U&gt; {
  var wrappedValue: (T) -&gt; U? { ... }
}

@Function var f: (Int) -&gt; Float?   // infers T=Int, U=Float 
</code></pre>
<p>在任何情况下, 第一个封装器类型限制为等于 第一个指定的书面属性类型  . 此外, 对于任何辅助封装器属性,  上一个封装器的 <code>wrappedValue</code> 属性的类型 限制为 指定属性的书面类型. 最后,如果已经给出了类型注解 , 最后的封装器类型的 <code>wrappedValue</code> 属性的类型 等同于 类型注解. 如果这些规则无法推断出第一封装器类型的所有类型参数, 或者他们彼此不一致, 则该变量的格式错误. 例如:</p>
<pre><code>@Lazy&lt;Int&gt; var foo: Int  // okay
@Lazy&lt;Int&gt; var bar: Double  // error: Lazy&lt;Int&gt;.wrappedValue is of type Int, not Double
</code></pre>
<p>这个推导同样也可以提供原始属性的类型 (如果类型注解被漏掉了), 或者推导出被漏掉的泛型参数的类型注解. 例如 :</p>
<pre><code>@propertyWrapper
struct StringDictionary {
  var wrappedValue: [String: String]
}

@StringDictionary var d1.            // infers Dictionary&lt;String, String&gt;
@StringDictionary var d2: Dictionary // infers &lt;String, String&gt;
</code></pre>
<h3 id="自定义属性">自定义属性</h3>
<p>属性封装器是自定义属性的一种形式 , 其中属性语法用于 引用在Swift中声明的实体, 在语法上, 属性包装器的使用描述如下:</p>
<pre><code>attribute ::= '@' type-identifier expr-paren?
</code></pre>
<p>其中 <code>type-identifier</code> 必须引用属性封装器类型, 该类型可以包含泛型参数, 请注意,这允许对属性名称进行限定 , 例如  :</p>
<pre><code>@Swift.Lazy var foo = 1742
</code></pre>
<p>如果存在 <code>expr-paren</code> ,则为封装器实例提供初始化参数.<br>
自定义属性的这种表述适合于<code>larger proposal for custom attributes</code> ,该建议使用与上诉相同的自定义属性语法, 但允许采用其他方式定义一个类型以用作属性 . 在此方案中, <code>@propertyWrapper</code> 只是一种自定义属性: 还有其他种类的自定义属性 仅在编译时 (例如, 对于工具) 或运行时(通过某种反射功能) 可用.</p>
<h3 id="封装器属性的可变性">封装器属性的可变性</h3>
<p>通常来说, 具有属性封装器的属性将同时具有 getter 和 setter . 但是 , 如果属性封装器类型的 <code>wrappedValue</code> 属性缺少设置器, 或者无法访问 setter  ,则该setter 可能会丢失 .<br>
如果属性封装器的<code>wrappedValue</code> 属性是<code>mutating</code> 并且 属性是<code>struct</code>的一部分, 则合成getter 将会设置为 <code>mutating</code> . 同样 ,如果属性封装器类型的 <code>wrappedValue</code> 属性具有 <code>nonmutating</code> setter 或 属性封装器是 <code>class</code> , 则 合成的 setter 将是 <code>nonmutating</code>  . 例如 :</p>
<pre><code>@propertyWrapper
struct MutatingGetterWrapper&lt;Value&gt; {
  var wrappedValue: Value {
    mutating get { ... }
    set { ... }
  }
}

@propertyWrapper
struct NonmutatingSetterWrapper&lt;Value&gt; {
  var wrappedValue: Value {
    get { ... }
    nonmutating set { ... }
  }
}

@propertyWrapper
class ReferenceWrapper&lt;Value&gt; {
  var wrappedValue: Value
}

struct Usewrappers {
  // x's getter is mutating
  // x's setter is mutating
  @MutatingGetterWrapper var x: Int

  // y's getter is nonmutating
  // y's setter is nonmutating
  @NonmutatingSetterWrapper var y: Int
  
  // z's getter is nonmutating
  // z's setter is nonmutating
  @ReferenceWrapper var z: Int  
}
</code></pre>
<h3 id="使用封装器进行属性的离线初始化">使用封装器进行属性的离线初始化</h3>
<p>有封装器的属性可以在定义后被初始化,或者通过属性本身( 如果封装器类型有 <code>init(wrappedValue:)</code> 构造器) , 或者通过合成存储属性 例如 :</p>
<pre><code>@Lazy var x: Int
// ...
x = 17   // okay, treated as _x = .init(wrappedValue: 17)
</code></pre>
<p>合成存储属性也可以直接初始化 ,例如 :</p>
<pre><code>@UnsafeMutable var y: Int
// ...
_y = UnsafeMutable&lt;Int&gt;(pointer: addressOfInt) // okay
</code></pre>
<p>请注意,定义初始化(DI)规则适用于具有封装器的属性.  让我们扩展上面<code>x</code> 的示例,来重新赋值并使用<code>var</code> :</p>
<pre><code>@Lazy var x2: Int
// ...
x2 = 17   // okay, treated as _x2 = .init(wrappedValue: 17)
// ...
x2 = 42   // okay, treated as x2 = 42 (calls the Lazy.wrappedValue setter)
</code></pre>
<h3 id="成员构造器">成员构造器</h3>
<p>结构体基于结构体中的存储属性隐式声明了成员构造器 . 对于有属性封装器的属性来说 ,该属性是从技术上计算出来的, 因为他是存储的(封装器类型的)合成属性 . 有属性封装器的实例属性需要 在 成员构造器中拥有相对应的参数 ,其类型将是原始属性类型或封装器类型, 具体取决于 封装器类型和初始值(如果提供了的话) . 具体的来说, 如果满足一下任一条件,则具有属性封装器的实例属性的成员构造器参数将会有一个原始属性类型 :</p>
<ul>
<li>对应的属性具有 使用<code>=</code>语法指定的初始值. 例如: <code>@Lazy var i = 17</code> ,或者</li>
<li>对应的属性没有初始值 ,但是属性封装器类型使用了 <code>init(wrappedValue:)</code></li>
</ul>
<p>否则 ,该成员构造器将需要有和封装器类型相同的的初始化参数.例如:</p>
<pre><code>struct Foo {
  @UserDefault(key: &quot;FOO_FEATURE_ENABLED&quot;, defaultValue: false)
  var x: Bool
  @Lazy var y: Int = 17
  @Lazy(closure: { getBool() }) var z: Bool
  @CopyOnWrite var w: Image

  // implicit memberwise initializer:
  init(x: UserDefault&lt;Bool&gt; = UserDefault(key: &quot;FOO_FEATURE_ENABLED&quot;, defaultValue: false),
       y: Int = 17,
       z: Lazy&lt;Bool&gt; = Lazy(closure: { getBool() }),
       w: Image) {
    self._x = x
    self._y = Lazy(wrappedValue: y)
    self._z = z
    self._w = CopyOnWrite(wrappedValue: w)
  }
}
</code></pre>
<h3 id="codable-hashable-and-equatable-synthesis">Codable, Hashable, and Equatable synthesis</h3>
<p><code>Codable</code>, <code>Hashable</code>,  <code>Equatable</code>  的合成使用备用存储属性. 这允许属性封装器类型来确定其自身的序列化和相等行为. 对于 <code>Encodable</code> 和 <code>Decodable</code> , 用于 &quot;keyed archiving&quot; 的名称就是原始属性声明(不带 <code>_</code>) 名称.</p>
<h3 id="标识符">$ 标识符</h3>
<p>目前来说 , 以<code>$</code> 开始的标识符是在Swift 编程时是不允许的. 如今, 此类标识符仅在 LLDB中使用, 他们可以用作在调试会话中的持久数据的名称.<br>
当前提案略微放松了这项规则:  Swift 编译器将引入以<code>$</code>开头的标识符(对于映射属性) ,并且Swift代码中可以引用这些属性. 但是, Swift 代码不能声明任何以<code>$</code>开头的标识符的新实体 . 例如:</p>
<pre><code>@CopyOnWrite var x = UIBezierPath()
print($x)                 // okay to refer to compiler-defined $x
let $y = UIBezierPath()   // error: cannot declare entity with $-prefixed name '$y'
</code></pre>
<h3 id="映射">映射</h3>
<p>属性封装器可以选择提供一个映射属性(例如: <code>$foo</code>), 通过定义<code>projectedValue</code> 属性来为每个封装的属性公开更多的API .<br>
就像 <code>wrappedValue</code> 属性 和<code>init(wrappedValue:)</code> 一样 , <code>projectedValue</code> 属性一定要和其属性封装器相同的访问等级. 例如 :</p>
<pre><code>class StorageManager {
  func allocate&lt;T&gt;(_: T.Type) -&gt; UnsafeMutablePointer&lt;T&gt; { ... }
}

@propertyWrapper
struct LongTermStorage&lt;Value&gt; {
  let pointer: UnsafeMutablePointer&lt;Value&gt;

  init(manager: StorageManager, initialValue: Value) {
    pointer = manager.allocate(Value.self)
    pointer.initialize(to: initialValue)
  }

  var wrappedValue: Value {
    get { return pointer.pointee }
    set { pointer.pointee = newValue }
  }

  var projectedValue: UnsafeMutablePointer&lt;Value&gt; {
    return pointer
  }
}
</code></pre>
<p>当我们使用<code>LongTermStorage</code> 封装器时 , 它处理与<code>StorageManager</code> 的协调, 并提供直接访问 或者 <code>UnsafeMutablePointer</code> 来操作值:</p>
<pre><code>let manager = StorageManager(...)

@LongTermStorage(manager: manager, initialValue: &quot;Hello&quot;)
var someValue: String

print(someValue)     // prints &quot;Hello&quot;
someValue = &quot;World&quot;  // update the value in storage to &quot;World&quot;

// $someValue accesses the projectedValue property of the wrapper instance, which
// is an UnsafeMutablePointer&lt;String&gt;
let world = $someValue.move()   // take value directly from the storage
$someValue.initialize(to: &quot;New value&quot;)
</code></pre>
<p>映射属性和原始属性有相同的访问级别.</p>
<pre><code>@LongTermStorage(manager: manager, initialValue: &quot;Hello&quot;)
public var someValue: String
</code></pre>
<p>可以转换成:</p>
<pre><code>private var _someValue: LongTermStorage&lt;String&gt; = LongTermStorage(manager: manager, initialValue: &quot;Hello&quot;)

public var $someValue: UnsafeMutablePointer&lt;String&gt; {
  get { return _someValue.projectedValue }
}

public var someValue: String {
  get { return _someValue.wrappedValue }
  set { _someValue.wrappedValue = newValue }
}
</code></pre>
<p>请注意 ,在这个示例中, <code>$someValue</code> 是不可写的. 因为 <code>projectedValue</code>属性是<code>get-only</code> 的属性.<br>
当多个属性封装器应用于指定的属性时, 将仅考虑最外层的属性封装器的<code>projectedValue</code> .</p>
<h3 id="属性封装器的使用限制">属性封装器的使用限制</h3>
<p>定义属性时, 使用属性封装器有很多限制 :</p>
<ul>
<li>带封装器的属性不能被声明到 <code>protocol</code>中 .</li>
<li>带封装器的实例属性不能被声明到 <code>extension</code> 中 .</li>
<li>带封装器的实例属性不能被声明到 <code>enum</code> 中 .</li>
<li><code>class</code> 中声明的带封装器的属性不能重写其他的属性.</li>
<li>带封装器的属性 不能被 <code>lazy</code> , <code>@NSCopying</code> , <code>@NSManaged</code> , <code>weak</code> , <code>unowned</code> 修饰.</li>
<li>带封装器的属性必须是其封闭声明中唯一声明的属性. (例如 <code>@Lazy var (x, y) = /* ... */</code> 就是错误的).</li>
<li>带封装器的属性不应该定义 getter / setter</li>
<li>属性封装器的 <code>wrappedValue</code> 属性和 <code>init(wrappedValue:)</code> (如果存在的话)  的访问等级应该和该封装器类型一致.</li>
<li>属性封装器的 <code>projectedValue</code> 属性 (如果存在的话) 的访问等级应该和该封装器类型一致.</li>
<li>属性封装器的 <code>init()</code> 构造器 (如果存在的话) 的访问等级应该和该封装器类型一致.</li>
</ul>
<h2 id="对现有代码的影响">对现有代码的影响</h2>
<p>就其本身而言 , 这是一个附加功能 , 不会影响现有代码. 但是, 在建议使用某些属性封装器的情况下,它可能会使现有的硬编码语言功能过时. <code>@NSCopying</code>可以完全替换为<code>Foundation</code>模块中引入的<code>Copying</code>属性封装器类型. <code>lazy</code>不能完全替换, 因为它的初始值可以引用封闭类型的自身; 请参阅 'deferred evaluation of initialization expressions ', 但是，引入<code>Lazy</code>属性封装器类型以覆盖许多常见用例仍然有意义，而将更神奇的<code>lazy</code> 留作向后兼容功能。</p>
<h2 id="向后兼容">向后兼容</h2>
<p>提议的属性封装器语言功能对ABI或运行时没有影响。 使用属性封装器的二进制文件可以向后部署到Swift 5.0运行时。</p>
<h2 id="替代方案">替代方案</h2>
<h3 id="组合">组合</h3>
<p>在提议的第一个修订版中是没有包括组合的 , 因为可以手动组合属性封装器类型 . 例如, <code>@A @B</code>的组合可以实现为<code>AB</code> 封装器 :</p>
<pre><code>@propertyWrapper
struct AB&lt;Value&gt; {
  private var storage: A&lt;B&lt;Value&gt;&gt;
  
  var wrappedValue: Value {
    get { storage.wrappedValue.wrappedValue }
    set { storage.wrappedValue.wrappedValue = newValue }
  }
}
</code></pre>
<p>这个方法的主要优点是可预测性 :  <code>AB</code> 的作者决定如何最好的实现 <code>A</code> 和 <code>B</code> 的组合, 适当的命令, 并且提供正确的API  和有关语义的文档. 另外一方面 , 必须手动写出的每个组合都是很多样板 ,特别是对于  主要卖点 是消除样板的特征 . 同时 不幸的的是, 必须要为每个组合 命名 --- 当我尝试 通过<code>@A</code> 和 <code>@B</code> 来组合成 <code>A</code> 和 <code>B</code> 时 ,我怎么知道去寻找那些手动组合的属性封装器类型<code>AB</code> ?  或者那应该是 <code>BA</code> ?</p>
<h3 id="通过嵌套类型查找来组合">通过嵌套类型查找来组合</h3>
<p>一种建议的组合方法仅直接解决上述最后一个问题，将属性组合语法<code>@A</code> <code>@B</code>视为对<code>A</code>内嵌套类型<code>B</code>的查找，以找到封装器类型：</p>
<pre><code>@propertyWrapper
struct A&lt;Value&gt; {
  var wrappedValue: Value { ... }
}

extension A {
  typealias B = AB&lt;Value&gt;
}
</code></pre>
<p>这可以使自然合成语法<code>@A</code> <code>@B</code> 起作用 ,重定向到实现正确语义和API的手动编写的属性封装器 .  此外, 这个方案还可以运行哪个组合是有效的 : 如果 <code>A</code> 中没有嵌套属性<code>B</code> , 则该组合无效. 如果 <code>A.B</code> 和 <code>B.A</code> 都存在的话,我们可以选择 . 将可以交换的语义作为语言的一部分 ( <code>B.A</code> 和 <code>A.B</code> 必须引用相同的类型, 或者 <code>@A @B</code>组合的格式不正确)</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#property-wrappers-%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%E5%99%A8">Property Wrappers ( 属性封装器 )</a>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%8A%A8%E6%9C%BA">动机</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a>
<ul>
<li><a href="#%E5%BB%B6%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96">延时初始化</a></li>
<li><a href="#nscopying">NSCopying</a></li>
<li><a href="#%E5%8E%9F%E5%AD%90%E6%80%A7">原子性</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%82%A8">指定线程存储</a></li>
<li><a href="#user-defaults">User defaults</a></li>
<li><a href="#copy-on-write">Copy-on-write</a></li>
<li><a href="#ref-box">Ref / Box</a></li>
<li><a href="#%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%80%BC">&quot;限制&quot;范围内的值</a></li>
<li><a href="#property-wrapper-types-in-the-wild">Property wrapper types in the wild</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88">属性封装器的组合</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82">设计细节</a>
<ul>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B">属性封装器类型</a></li>
<li><a href="#%E5%90%88%E6%88%90%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">合成存储属性的初始化</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%E5%99%A8%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">使用属性封装器进行类型推导</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7">自定义属性</a></li>
<li><a href="#%E5%B0%81%E8%A3%85%E5%99%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7">封装器属性的可变性</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%88%9D%E5%A7%8B%E5%8C%96">使用封装器进行属性的离线初始化</a></li>
<li><a href="#%E6%88%90%E5%91%98%E6%9E%84%E9%80%A0%E5%99%A8">成员构造器</a></li>
<li><a href="#codable-hashable-and-equatable-synthesis">Codable, Hashable, and Equatable synthesis</a></li>
<li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">$ 标识符</a></li>
<li><a href="#%E6%98%A0%E5%B0%84">映射</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6">属性封装器的使用限制</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E7%8E%B0%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BD%B1%E5%93%8D">对现有代码的影响</a></li>
<li><a href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9">向后兼容</a></li>
<li><a href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">替代方案</a>
<ul>
<li><a href="#%E7%BB%84%E5%90%88">组合</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B%E6%9F%A5%E6%89%BE%E6%9D%A5%E7%BB%84%E5%90%88">通过嵌套类型查找来组合</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://v1ki.top/post/swift-evolution-0276-multi-pattern-catch-clauses">
              <h3 class="post-title">
                swift-evolution 0276 Multi-Pattern Catch Clauses 
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '089c19b8ce1ee9af803f',
    clientSecret: '5f7616f447cb731d641d11ae471f47bbc38d95b0',
    repo: 'V1ki.github.io',
    owner: 'V1ki',
    admin: ['V1ki'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://v1ki.top//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
