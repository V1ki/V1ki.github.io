<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>swift-evolution 0258-property-wrappers | 浮生闲记</title>
<meta name="description" content="要么有趣,要么老去." />
<link rel="shortcut icon" href="http://v1ki.top//favicon.ico?v=1579670681627">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="http://v1ki.top//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-153511680-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-153511680-1');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://v1ki.top/">
  <img class="avatar" src="http://v1ki.top//images/avatar.png?v=1579670681627" alt="">
  </a>
  <h1 class="site-title">
    浮生闲记
  </h1>
  <p class="site-description">
    要么有趣,要么老去.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              swift-evolution 0258-property-wrappers
            </h2>
            <div class="post-info">
              <span>
                2020-01-21
              </span>
              <span>
                18 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>原文链接： <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md">0258-property-wrappers</a></p>
<h1 id="property-wrappers-属性封装器">Property Wrappers ( 属性封装器 )</h1>
<h2 id="前言">前言</h2>
<p>  有一些属性实现模式总是反复出现,而不是将一组固定的模式硬编码至编译器 ( 就像 <code>lazy</code>  和 <code>@NSCopying</code> 这样 ) . 我们应该提供一个常用的 “ 属性封装器 ” 机制来让这些模式可以被定义为库.<br>
   这个可以为作为替代  <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md">2015-2016 property behaviors proposal</a>   的一些问题的解决方案. 一些示例是相同的, 但是这个提案一个完整的不同的方式 , 使得设计变得更加简单 , 更容易被用户理解 , 并且对编译器的实施的侵入性更少 . 在本提案末尾 , 有一节讨论了与该设计的实质区别.</p>
<h2 id="动机">动机</h2>
<p>我们已尝试对于 目标语言支持的属性提供几种重要的模式 .比如说 <code>lazy</code>和 <code>@NSCopying</code> , 但是这种支持的范围和实用性一直很狭窄 . 例如 , Swift 提供 <code>lazy</code> 属性作为语言的原生特性.  因为懒加载是很常见的, 并且通常是避免属性作为 <code>Optional</code>  是必需的. 如果没有了这个语言特性,  将会花很多代码来达成相同的效果.</p>
<pre><code>struct Foo {
  // lazy var foo = 1738
  private var _foo: Int?
  var foo: Int {
    get {
      if let value = _foo { return value }
      let initialValue = 1738
      _foo = initialValue
      return initialValue
    }
    set {
      _foo = newValue
    }
  }
}
</code></pre>
<p>将<code>lazy</code> 构建进Swfit 有几个缺点. 他使 Swift和其编译器变得更加复杂 , 且不那么正交. 而且也不灵活.  有很多有意义的懒加载变体,但是我们不想对所有的进行硬编码语言支持.</p>
<p>除了懒加载之后 , 还有一些重要的属性模式 , 拥有 &quot;延时 &quot;, 一旦赋值然后就不可变的属性 来支持 多个阶段的初始化通常是有意义:</p>
<pre><code>class Foo {
  let immediatelyInitialized = &quot;foo&quot;
  var _initializedLater: String?

  // We want initializedLater to present like a non-optional 'let' to user code;
  // it can only be assigned once, and can't be accessed before being assigned.
  var initializedLater: String {
    get { return _initializedLater! }
    set {
      assert(_initializedLater == nil)
      _initializedLater = newValue
    }
  }
}
</code></pre>
<p>隐式展开的可选项允许在紧急情况下使用此选项 , 但是对比 一个非可选的 <code>let</code> 来说放弃了很多的安全性.  使用 IUO 来多阶段初始化 放弃了包括 不变性以及 nil-safety .</p>
<p><code>@NSCopying</code> 属性 引入了 <code>NSCopying.copy()</code>  来在分配时创建一个复制. 这个实现模式可能看起来很熟悉:</p>
<pre><code>class Foo {
  // @NSCopying var text: NSAttributedString
  var _text: NSAttributedString
  var text: NSAttributedString {
    get { return _text }
    set { _text = newValue.copy() as! NSAttributedString }
  }
}
</code></pre>
<h2 id="解决方案">解决方案</h2>
<p>我们建议引入属性封装器 , 该属性封装器 允许 属性在声明时决定让哪个封装 来实现他. 通过属性来描述 封装器 :</p>
<pre><code>@Lazy var foo = 1738
</code></pre>
<p>这以 <code>Lazy</code> 的属性封装器器 类型描述的方式来实现了<code>foo</code> 属性:</p>
<pre><code>@propertyWrapper
enum Lazy&lt;Value&gt; {
  case uninitialized(() -&gt; Value)
  case initialized(Value)

  init(wrappedValue: @autoclosure @escaping () -&gt; Value) {
    self = .uninitialized(wrappedValue)
  }

  var wrappedValue: Value {
    mutating get {
      switch self {
      case .uninitialized(let initializer):
        let value = initializer()
        self = .initialized(value)
        return value
      case .initialized(let value):
        return value
      }
    }
    set {
      self = .initialized(newValue)
    }
  }
}
</code></pre>
<p>属性封装器 类型 提供了 将其用作 封装器的属性的存储 .   封装器类型的<code>wrappedValue</code> 属性 提供了封装器的实际实现. 可选的 <code>init(wrappedValue:)</code> 可以根据属性类型的值 来初始化存储  .   属性声明为:</p>
<pre><code>@Lazy var foo = 1738
</code></pre>
<p>转换为:</p>
<pre><code>private var _foo: Lazy&lt;Int&gt; = Lazy&lt;Int&gt;(wrappedValue: 1738)
var foo: Int {
  get { return _foo.wrappedValue }
  set { _foo.wrappedValue = newValue }
}
</code></pre>
<p>特意将前缀<code>_</code>用作 合成存储属性的名称: 它为合成存储属性 提供了一个可预测的名称, 该名称符合 <code>private</code> 存储属性的命名规范. 比如 ,我们可以 提供 一个 <code>reset(_:)</code> 操作符给 <code>Lazy</code> 来将它设置成一个新的值 :</p>
<pre><code>extension Lazy {
  /// Reset the state back to &quot;uninitialized&quot; with a new,
  /// possibly-different initial value to be computed on the next access.
  mutating func reset(_ newValue:  @autoclosure @escaping () -&gt; Value) {
    self = .uninitialized(newValue)
  }
}

_foo.reset(42)
</code></pre>
<p>这个备用的存储属性也可以被显式初始化,像这样:</p>
<pre><code>extension Lazy {
  init(body: @escaping () -&gt; Value) {
    self = .uninitialized(body)
  }
}

func createAString() -&gt; String { ... }

@Lazy var bar: String  // not initialized yet
_bar = Lazy(body: createAString)
</code></pre>
<p>属性封装器的实例 可以通过提供一个在名称后括号中的初始化参数来直接初始化.  上面的代码可以替换成一个简单的声明 ,如下所示 :</p>
<pre><code>@Lazy(body: createAString) var bar: String
</code></pre>
<p>属性封装器可以被应用到全局, 局部, 或类型范围的属性. 这些属性可以拥有观察访问者 ( <code>willSet / didSet</code> ) ,但是不能具有显示编写 的<code>getters</code> 或者 <code>setter</code>  .</p>
<p><code>Lazy</code> 属性封装器在它的构造器之外几乎没有 或者 没有有趣的API . 因此将其导出给客户并不重要. 但是 , 属性封装器也可以描述本身就有 有趣 API的 丰富关系 . 例如 , 我们可能会有一个属性封装器的概念, 该属性封装器引用了一个通过名称来建立的数据库字段 .</p>
<pre><code>@propertyWrapper
public struct Field&lt;Value: DatabaseValue&gt; {
  public let name: String
  private var record: DatabaseRecord?
  private var cachedValue: Value?
  
  public init(name: String) {
    self.name = name
  }

  public func configure(record: DatabaseRecord) {
    self.record = record
  }
  
  public var wrappedValue: Value {
    mutating get {
      if cachedValue == nil { fetch() }
      return cachedValue!
    }
    
    set {
      cachedValue = newValue
    }
  }
  
  public func flush() {
    if let value = cachedValue {
      record!.flush(fieldName: name, value)
    }
  }
  
  public mutating func fetch() {
    cachedValue = record!.fetch(fieldName: name, type: Value.self)
  }
}
</code></pre>
<p>我们可以基于 <code>Field</code> 属性封装器来建立我们自己的数据模型.</p>
<pre><code>public struct Person: DatabaseModel {
  @Field(name: &quot;first_name&quot;) public var firstName: String
  @Field(name: &quot;last_name&quot;) public var lastName: String
  @Field(name: &quot;date_of_birth&quot;) public var birthdate: Date
}
</code></pre>
<p><code>Field</code> 本身具有对<code>Person</code> 用户重要的API : 它让我们可以刷新现有值. 获取新的值, 并且检索数据库中相应字段的名称. 但是 , 我们模型中的每个属性(<code>_firstName</code>, <code>_lastName</code>,<code>_birthdate</code>) 的 带下划线变量都是 <code>private</code> , 所以我们的用户无法直接操作它们.</p>
<p>为了发布API, <code>Field</code> 属性封装器可以提供 一个映射来让我们操作 字段与数据库之间的关系. 映射属性 带有 <code>$</code>前缀, 所以 <code>firstName</code> 属性的映射属性被称为 <code>$firstName</code> ,并且当 <code>firstName</code>可见时也可见. 属性封装器类型 通过定义 <code>projectedValue</code> 属性来选择提供映射 :</p>
<pre><code>@propertyWrapper
public struct Field&lt;Value: DatabaseValue&gt; {
  // ... API as before ...
  
  public var projectedValue: Self {
    get { self }
    set { self = newValue }
  }
}
</code></pre>
<p>当<code>projectedValue</code> 存在时, 映射属性被创建为<code>projectedValue</code> 的封装器 . 例如 , 如下属性为:</p>
<pre><code>@Field(name: &quot;first_name&quot;) public var firstName: String
</code></pre>
<p>可以扩展为:</p>
<pre><code>private var _firstName: Field&lt;String&gt; = Field(name: &quot;first_name&quot;)

public var firstName: String {
  get { _firstName.wrappedValue }
  set { _firstName.wrappedValue = newValue }
}

public var $firstName: Field&lt;String&gt; {
  get { _firstName.projectedValue }
  set { _firstName.projectedValue = newValue }
}
</code></pre>
<p>这个允许用户同时操作属性和其映射 , 例如:</p>
<pre><code>somePerson.firstName = &quot;Taylor&quot;
$somePerson.flush()
</code></pre>
<h2 id="示例">示例</h2>
<p>在描述设计细节之前,下面有几个封装器的示例</p>
<h3 id="延时初始化">延时初始化</h3>
<p>属性封装器可以 &quot;延迟&quot; 初始化进行建模 , 在该初始化中, 属性的定义初始化(DI)规则是强制动态执行的 , 而不是在编译时执行的. 这个可以避免在多阶段初始化中使用隐式展开的可选对象. 我们可以实现一个可变的变量,允许像<code>var</code> 一样重复赋值.</p>
<pre><code>@propertyWrapper
struct DelayedMutable&lt;Value&gt; {
  private var _value: Value? = nil

  var wrappedValue: Value {
    get {
      guard let value = _value else {
        fatalError(&quot;property accessed before being initialized&quot;)
      }
      return value
    }
    set {
      _value = newValue
    }
  }

  /// &quot;Reset&quot; the wrapper so it can be initialized again.
  mutating func reset() {
    _value = nil
  }
}
</code></pre>
<p>和一个不变的变量, 像<code>let</code>一样只允许一次初始化  :</p>
<pre><code>@propertyWrapper
struct DelayedImmutable&lt;Value&gt; {
  private var _value: Value? = nil

  var wrappedValue: Value {
    get {
      guard let value = _value else {
        fatalError(&quot;property accessed before being initialized&quot;)
      }
      return value
    }

    // Perform an initialization, trapping if the
    // value is already initialized.
    set {
      if _value != nil {
        fatalError(&quot;property initialized twice&quot;)
      }
      _value = newValue
    }
  }
}
</code></pre>
<p>可以多阶段初始化,像这样:</p>
<pre><code>class Foo {
  @DelayedImmutable var x: Int

  init() {
    // We don't know &quot;x&quot; yet, and we don't have to set it
  }

  func initializeX(x: Int) {
    self.x = x // Will crash if 'self.x' is already initialized
  }

  func getX() -&gt; Int {
    return x // Will crash if 'self.x' wasn't initialized
  }
}
</code></pre>
<h3 id="nscopying">NSCopying</h3>
<p>许多Cocoa class 都实现 需要显式复制<code>value-like</code> 对象 . Swift 当前为属性提供 <code>@NSCopying</code> 属性 , 以赋予它们类似 Objective-C 的 <code>@property(copy)</code> 的行为,并且在设置属性时在新对象时调用 <code>copy</code> 方法. 我们可以将其变成封装器:</p>
<pre><code>@propertyWrapper
struct Copying&lt;Value: NSCopying&gt; {
  private var _value: Value
  
  init(wrappedValue value: Value) {
    // Copy the value on initialization.
    self._value = value.copy() as! Value
  }

  var wrappedValue: Value {
    get { return _value }
    set {
      // Copy the value on reassignment.
      _value = newValue.copy() as! Value
    }
  }
}
</code></pre>
<p>此实现将解决<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.md">SE-0153</a>中详述的问题.将<code>copy()</code>放在<code>init(wrappedValue:)</code>之外可实现 SE-0153 前的语义.</p>
<h3 id="原子性">原子性</h3>
<p>对 原子操作符( load , store , increment / decrement , compare-and-exchange ) 的支持是一种常见的Swift 功能. 尽管此功能的实现细节涉及到编译器和标准库魔术, 这些接口本身可以很好的表示属性封装器类型 :</p>
<pre><code>@propertyWrapper
struct Atomic&lt;Value&gt; {
  private var _value: Value
  
  init(wrappedValue: Value) {
    self._value = wrappedValue
  }

  var wrappedValue: Value {
    get { return load() }
    set { store(newValue: newValue) }
  }
  
  func load(order: MemoryOrder = .relaxed) { ... }
  mutating func store(newValue: Value, order: MemoryOrder = .relaxed) { ... }
  mutating func increment() { ... }
  mutating func decrement() { ... }
}

extension Atomic where Value: Equatable {
  mutating func compareAndExchange(oldValue: Value, newValue: Value, order: MemoryOrder = .relaxed)  -&gt; Bool { 
    ...
  }
}  

enum MemoryOrder {
  case relaxed, consume, acquire, release, acquireRelease, sequentiallyConsistent
};
</code></pre>
<p>这里有一些简单关于原子性的使用. 对于原子性类型来说, 通常需要编织低等级的原子操作符(<code>increment</code>, <code>load</code>, <code>compareAndExchange</code>)  ,在这些操作中,我们需要通过简单查询获得特定语义(例如内存顺序), 因此经常使用该属性和合成属性:</p>
<pre><code>@Atomic var counter: Int

if thingHappened {
  _counter.increment()
}
print(counter)

@Atomic var initializedOnce: Int?
if initializedOnce == nil {
  let newValue: Int = /*computeNewValue*/
  if !_initializedOnce.compareAndExchange(oldValue: nil, newValue: newValue) {
    // okay, someone else initialized it. clean up if needed
  }
}
print(initializedOnce)
</code></pre>
<h3 id="指定线程存储">指定线程存储</h3>
<p>指定线程存储 (基于<code>pthreads</code>) 可以作为一个 属性封装器实现 :</p>
<pre><code>@propertyWrapper
final class ThreadSpecific&lt;T&gt; {
  private var key = pthread_key_t()
  private let initialValue: T

  init(key: pthread_key_t, wrappedValue: T) {
    self.key = key
    self.initialValue = wrappedValue
  }

  init(wrappedValue: T) {
    self.initialValue = wrappedValue
    pthread_key_create(&amp;key) {
      // 'Any' erasure due to inability to capture 'self' or &lt;T&gt;
      $0.assumingMemoryBound(to: Any.self).deinitialize(count: 1)
      $0.deallocate()
    }
  }

  deinit {
    fatalError(&quot;\(ThreadSpecific&lt;T&gt;.self).deinit is unsafe and would leak&quot;)
  }

  private var box: UnsafeMutablePointer&lt;Any&gt; {
    if let pointer = pthread_getspecific(key) {
      return pointer.assumingMemoryBound(to: Any.self)
    } else {
      let pointer = UnsafeMutablePointer&lt;Any&gt;.allocate(capacity: 1)
      pthread_setspecific(key, UnsafeRawPointer(pointer))
      pointer.initialize(to: initialValue as Any)
      return pointer
    }
  }

  var wrappedValue: T {
    get { return box.pointee as! T }
    set (v) {
      box.withMemoryRebound(to: T.self, capacity: 1) { $0.pointee = v }
    }
  }
}
</code></pre>
<h3 id="user-defaults">User defaults</h3>
<p>属性封装器可用于为 &quot;string-keyed&quot; 的数据提供类型化的属性, 就像  UserDefaults , 将提取数据的机制封装在封装器类型中. 例如:</p>
<pre><code>@propertyWrapper
struct UserDefault&lt;T&gt; {
  let key: String
  let defaultValue: T
  
  var wrappedValue: T {
    get {
      return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
    }
    set {
      UserDefaults.standard.set(newValue, forKey: key)
    }
  }
}

enum GlobalSettings {
  @UserDefault(key: &quot;FOO_FEATURE_ENABLED&quot;, defaultValue: false)
  static var isFooFeatureEnabled: Bool
  
  @UserDefault(key: &quot;BAR_FEATURE_ENABLED&quot;, defaultValue: false)
  static var isBarFeatureEnabled: Bool
}
</code></pre>
<h3 id="copy-on-write">Copy-on-write</h3>
<p>对于一些场景来说 , 属性封装器可以提供 <code>copy-on-write</code> 封装器 :</p>
<pre><code>protocol Copyable: AnyObject {
  func copy() -&gt; Self
}

@propertyWrapper
struct CopyOnWrite&lt;Value: Copyable&gt; {
  init(wrappedValue: Value) {
    self.wrappedValue = wrappedValue
  }
  
  private(set) var wrappedValue: Value
  
  var projectedValue: Value {
    mutating get {
      if !isKnownUniquelyReferenced(&amp;wrappedValue) {
        wrappedValue = value.copy()
      }
      return wrappedValue
    }
    set {
      wrappedValue = newValue
    }
  }
}
</code></pre>
<p><code>projectedValue</code> 为合成存储属性提供映射,允许 <code>copy-on-write</code> 封装器直接可以直接被使用:</p>
<pre><code>@CopyOnWrite var storage: MyStorageBuffer

// Non-modifying access:
let index = storage.index(of: …)

// For modification, access $storage, which goes through `projectedValue`:
$storage.append(…)
</code></pre>
<h3 id="ref-box">Ref / Box</h3>
<p>我们可以定义一个属性封装器类型 <code>Ref</code> ,它是对 可以 获取/设置的某些值的抽象引用, 它实际上是一个程序化的计算类型 .</p>
<pre><code>@propertyWrapper
struct Ref&lt;Value&gt; {
  let read: () -&gt; Value
  let write: (Value) -&gt; Void

  var wrappedValue: Value {
    get { return read() }
    nonmutating set { write(newValue) }
  }

  subscript&lt;U&gt;(dynamicMember keyPath: WritableKeyPath&lt;Value, U&gt;) -&gt; Ref&lt;U&gt; {
    return Ref&lt;U&gt;(
        read: { self.wrappedValue[keyPath: keyPath] },
        write: { self.wrappedValue[keyPath: keyPath] = $0 })
  }
}
</code></pre>
<p>下标使用 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0252-keypath-dynamic-member-lookup.md">SE-0252 &quot;Key Path Member Lookup&quot;</a> , 以便 <code>Ref</code> 实例提供访问其属性. 下面示例以SE-0252为基础:</p>
<pre><code>@Ref(read: ..., write: ...)
var rect: Rectangle

print(rect)          // accesses the Rectangle
print(rect.topLeft)  // accesses the topLeft component of the rectangle

let rect2 = $rect    // get the Ref&lt;Rectangle&gt;
let topLeft2 = $rect.topLeft // get a Ref&lt;Point&gt; referring to the Rectangle's topLeft
</code></pre>
<p><code>Ref</code> 类型封装 读/写 ,并使其成为 属性封装器 ,  这样我们就可以看到基础值了.  通常, 人们不想显示写出 <code>getter</code> / <code>setter</code> ,并且拥有 <code>Box</code> 类型来包装一个值并可以 将 <code>Ref</code> 实例发布给 该 box 是很常见的. 我们也可以使用另外一种属性封装器实现 :</p>
<pre><code>@propertyWrapper
class Box&lt;Value&gt; {
  var wrappedValue: Value

  init(wrappedValue: Value) {
    self.wrappedValue = wrappedValue
  }

  var projectedValue: Ref&lt;Value&gt; {
    return Ref&lt;Value&gt;(read: { self.wrappedValue }, write: { self.wrappedValue = $0 })
  }
}
</code></pre>
<p>现在我们可以直接定义一个新的 <code>Box</code> :</p>
<pre><code>@Box var rectangle: Rectangle = ...

print(rectangle)  // access the rectangle
print(rectangle.topLeft) // access the top left coordinate of the rectangle
let rect2 = $rectangle   // through projectedValue, produces a Ref&lt;Rectangle&gt;
let topLeft2 = $rectangle.topLeft   // through projectedValue, produces a Ref&lt;Point&gt;
</code></pre>
<p>使用<code>projectedValue</code> 会隐藏用户的box( <code>_rectangle</code> 保持私有 ) ,提供直接访问到box的值(通常状态下)  以及通过<code>Ref</code>(称为<code>$rectangle</code>)访问box的内容.</p>
<h3 id="限制范围内的值">&quot;限制&quot;范围内的值</h3>
<p>属性封装器可以限制存储值在特定范围内, 例如 , <code>Clamping</code> 属性封装器提供 最小/最大范围 来将值限制在其中 :</p>
<pre><code>@propertyWrapper
struct Clamping&lt;V: Comparable&gt; {
  var value: V
  let min: V
  let max: V

  init(wrappedValue: V, min: V, max: V) {
    value = wrappedValue
    self.min = min
    self.max = max
    assert(value &gt;= min &amp;&amp; value &lt;= max)
  }

  var wrappedValue: V {
    get { return value }
    set {
      if newValue &lt; min {
        value = min
      } else if newValue &gt; max {
        value = max
      } else {
        value = newValue
      }
    }
  }
}
</code></pre>
<p>这个示例中最有趣的是 <code>@Clamping</code> 属性可以通过传递初始化参数或者给初始值来进行初始化 . 在这样的示例中, <code>wrappedValue:</code> 参数是放在第一位的. 例如, 我们可以定义一个 <code>Color</code> 类型,该类型的值被限制在[0,255] 的范围中了 :</p>
<pre><code>struct Color {
  @Clamping(min: 0, max: 255) var red: Int = 127
  @Clamping(min: 0, max: 255) var green: Int = 127
  @Clamping(min: 0, max: 255) var blue: Int = 127
  @Clamping(min: 0, max: 255) var alpha: Int = 255
}
</code></pre>
<p>合成成员式的构造器展示了初始化本身是如何形成的:</p>
<pre><code>init(red: Int = 127, green: Int = 127, blue: Int = 127, alpha: Int = 255) {
  _red = Clamping(wrappedValue: red, min: 0, max: 255)
  _green = Clamping(wrappedValue: green, min: 0, max: 255)
  _blue = Clamping(wrappedValue: blue, min: 0, max: 255)
  _alpha = Clamping(wrappedValue: alpha, min: 0, max: 255)
}
</code></pre>
<h3 id="property-wrapper-types-in-the-wild">Property wrapper types in the wild</h3>
<p>有许多现有的类型已经提供了属性封装器类型的基础结构 . 其中一个比较有趣的案例是 <code>Unsafe(Mutable)Pointer</code> , 我们可以对其进行扩展以允许轻松访问指向的值.</p>
<pre><code>@propertyWrapper
struct UnsafeMutablePointer&lt;Pointee&gt; {
  var pointee: Pointee { ... }
  
  var wrappedValue: Pointee {
    get { return pointee }
    set { pointee = newValue }
  }
}
</code></pre>
<p>从用户角度来看, 这使我们可以一次设置不安全可变的指针的地址,然后主要引用指向的值 :</p>
<pre><code>@UnsafeMutablePointer(mutating: addressOfAnInt)
var someInt: Int

someInt = 17 // equivalent to _someInt.pointee = 17
print(someInt)

_someInt.deallocate()
</code></pre>
<p>RxCocoa's <code>BehaviorRelay</code> 为每个订阅的观察者重放了提供的最新值. 它是使用初始值来创建 的, 有<code>wrappedValue</code> 属性来访问当前的值,并且<code>projectedValue</code>  来公开提供API的映射 来订阅新的观察者 :</p>
<pre><code>@BehaviorRelay
var myValue: Int = 17

let observer = $myValue.subscribe(...)   // subscribe an observer
$myValue.accept(42)  // set a new value via the synthesized storage property

print(myValue)   // print the most recent value
</code></pre>
<p>这和 Combine's <code>Published</code> 属性封装器很神似 , 允许用户来订阅 <code>@Published</code>属性(通过 <code>$</code> 来映射) 以在值发生变化的时接收更新.<br>
SwiftUI 广泛使用属性封装器来声明 局部状态( <code>@State</code> ) ,并表达了对可能影响UI的其他状态的数据依耐性(<code>@EnvironmentObject</code>, <code>@Environment</code>, <code>@ObjectBinding</code>). 它广泛使用了 <code>Binding</code> 属性封装器的映射,来允许影响UI的状态的可控变化.</p>
<h3 id="composition-of-property-wrappers">Composition of property wrappers</h3>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#property-wrappers-%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%E5%99%A8">Property Wrappers ( 属性封装器 )</a>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%8A%A8%E6%9C%BA">动机</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a>
<ul>
<li><a href="#%E5%BB%B6%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96">延时初始化</a></li>
<li><a href="#nscopying">NSCopying</a></li>
<li><a href="#%E5%8E%9F%E5%AD%90%E6%80%A7">原子性</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%82%A8">指定线程存储</a></li>
<li><a href="#user-defaults">User defaults</a></li>
<li><a href="#copy-on-write">Copy-on-write</a></li>
<li><a href="#ref-box">Ref / Box</a></li>
<li><a href="#%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%80%BC">&quot;限制&quot;范围内的值</a></li>
<li><a href="#property-wrapper-types-in-the-wild">Property wrapper types in the wild</a></li>
<li><a href="#composition-of-property-wrappers">Composition of property wrappers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://v1ki.top/post/swift-evolution-0276-multi-pattern-catch-clauses">
              <h3 class="post-title">
                swift-evolution 0276 Multi-Pattern Catch Clauses 
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '089c19b8ce1ee9af803f',
    clientSecret: '5f7616f447cb731d641d11ae471f47bbc38d95b0',
    repo: 'V1ki.github.io',
    owner: 'V1ki',
    admin: ['V1ki'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="http://v1ki.top//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
